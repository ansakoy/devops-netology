# Домашнее задание к занятию "6.4. PostgreSQL"
[Источник](https://github.com/netology-code/virt-homeworks/blob/virt-11/06-db-04-postgresql/README.md)
## Задача 1

> Используя docker поднимите инстанс PostgreSQL (версию 13). Данные БД сохраните в volume.
> 
> Подключитесь к БД PostgreSQL используя `psql`.
> 
> Воспользуйтесь командой `\?` для вывода подсказки по имеющимся в `psql` 
>управляющим командам.
> 
> **Найдите и приведите** управляющие команды для:
> - вывода списка БД
`\l`
> - подключения к БД
`\c`
> - вывода списка таблиц
`\dt`
> - вывода описания содержимого таблиц
`\d`
> - выхода из psql
`\q`

## Задача 2

>Используя `psql` создайте БД `test_database`.
>
>Изучите [бэкап БД](https://github.com/netology-code/virt-homeworks/tree/master/06-db-04-postgresql/test_data).
>
>Восстановите бэкап БД в `test_database`.
>
>Перейдите в управляющую консоль `psql` внутри контейнера.
>
>Подключитесь к восстановленной БД и проведите операцию ANALYZE для сбора статистики по таблице.
>
>Используя таблицу [pg_stats](https://postgrespro.ru/docs/postgresql/12/view-pg-stats), найдите столбец таблицы `orders` 
>с наибольшим средним значением размера элементов в байтах.
>
>**Приведите в ответе** команду, которую вы использовали для вычисления и полученный результат.

```

```

## Задача 3

>Архитектор и администратор БД выяснили, что ваша таблица orders разрослась до 
>невиданных размеров и поиск по ней занимает долгое время. 
>Вам, как успешному выпускнику курсов DevOps в нетологии предложили 
>провести разбиение таблицы на 2 (шардировать на orders_1 - price>499 и orders_2 - price<=499).
>
>Предложите SQL-транзакцию для проведения данной операции.

```

```
>Можно ли было изначально исключить "ручное" разбиение при проектировании таблицы orders?

```

```

## Задача 4

>Используя утилиту `pg_dump` создайте бекап БД `test_database`.
>
>Как бы вы доработали бэкап-файл, чтобы добавить уникальность значения столбца 
>`title` для таблиц `test_database`?

Вообще за "доработку" бэкап-файлов нужно отрывать руки. Поэтому если что-то такое 
делать, то потом это следует тщательно скрывать и никогда об этом никому не рассказывать. 
Если понадобилось обеспечить уникальность значений в столбце, то это надо делать 
путем изменения схемы в работающей базе:
```sql
alter table table_name add constraint constraint_name unique column_name;
```
От этого, конечно, полезут ошибки в случае, если там уже есть неуникальные значения, 
и надо будет их сначала извести, затем добавить уникальность, а потом сделать дамп 
с новой версией схемы.  
Еще более жизненный вариант - это поправить схему, написанную в какой-нибудь ORM, 
смигрировать ее в базу (исправив вылезшие ошибки) и опять же сделать дамп с новой схемой.  
Но у меня есть нехорошее подозрение, что в задании требуется сделать ужасное, то есть 
открыть файл с дампом и прямо написать там что-то в духе:
```
CREATE TABLE public.orders (
    id integer NOT NULL,
    title character varying(80) NOT NULL UNIQUE,
    price integer DEFAULT 0
);
```
Мы, конечно, знаем, что так делать ни в коем случае нельзя.
