# Домашнее задание к занятию "6.6. Troubleshooting"

[Источник](https://github.com/netology-code/virt-homeworks/blob/virt-11/06-db-06-troobleshooting/README.md)

## Задача 1

> Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).
> 
> Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
> нужно прервать. 
> 
> Вы как инженер поддержки решили произвести данную операцию:
> - напишите список операций, которые вы будете производить для остановки запроса пользователя

Найти подвисшую операцию (допустим, на основании затраченного времени):
```
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 },
     "ns" : /^my_db\./
   }
)
```
Взять ее `opid` и убить:
```
db.killOp(opid)
```

> - предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Нужно проанализировать запрос и посмотреть, как он соотносится с состоянием базы.

С огромной вероятностью проблема окажется в том, что где-нибудь не проставлен индекс или, например, 
потерялся при восстановлении базы в новую версию монги. Лечится проставлением соответствующего индекса.  

Также проблема может быть в структуре самой коллекции (например, если там остроумный дизайнер решил сделать 
в документах массивы объектов с неконтролируемо растущим числом элементов, как это любят делать 
на budget.gov.ru). Тут в идеале нужно менять структуру коллекции - например, выносить объекты из этих массивов 
в отдельную коллекцию.

Еще есть вероятность, что в базе просто слишком много записей, и она начала тормозить. Можно попробовать решить 
шардированием. А также подумать о том, не стоит ли переместиться в какой-нибудь постгрес и разместить 
там те же записи в jsonb.

## Задача 2

> Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).
> 
> Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
> Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
> увеличивается пропорционально количеству реплик сервиса. 
> 
> При масштабировании сервиса до N реплик вы увидели, что:
> - сначала рост отношения записанных значений к истекшим
> - Redis блокирует операции записи
> 
> Как вы думаете, в чем может быть проблема?

Вообще для установления проблемы хорошо иметь больше информации. Redis предлагает для этого фичу 
под названием [Latency Monitoring](https://redis.io/docs/reference/optimization/latency-monitor/), которая 
позволяет посмотреть, какие события в жизни базы вызывают задержки.

В данном случае нам известно, что проблемы производительности возникли после масштабирования сервиса. 
После - не значит вследствие. По-прежнему, есть риск, что проблемы вызывают какие-то сторонние ресурсоемкие 
процессы или какие-то сетевые нестыковки.

Тем не менее, описанная ситуация напоминает [этот пассаж](https://redis.io/docs/reference/optimization/latency/#latency-generated-by-expires) 
из документации, который описывает замедление из-за большого количества истекших ключей. Это происходит за счет 
работы активного алгоритма удаления истекших ключей, который стремится к тому, чтобы их было не более 25%. 
Если он не успевает этого сделать (потому что их появляется слишком много за короткий отрезок времени), 
то Redis блокируется. В принципе эта версия хорошо согласуется с предшествующим масштабированием, которое, 
скорее всего, было решением в условиях высокой нагруженности.
 
## Задача 3

> Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
> пользователи начали жаловаться на ошибки вида:
> ```python
> InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
> ```
> 
> Как вы думаете, почему это начало происходить и как локализовать проблему?

Ситуация с потерей связи с сервером особо [оговаривается](https://dev.mysql.com/doc/refman/8.0/en/error-lost-connection.html) 
в документации MySQL. В первую очередь, рекомендуется обратить внимание на возможные сетевые проблемы.  
Еще это может быть вызвано перегруженностью базы - она пытается отправить несколько миллионов строк 
в ответ на один или несколько запросов.  
Реже встречается ситуация, когда пользователь пытается установить связь с сервером впервые и получает 
такой ответ.  
Для локализации проблемы в конкретном случае имеет смысл начать с логов СУБД, а дальше руководствоваться 
результатами их изучения и поисками проблемы по описанным направлениям.

> Какие пути решения данной проблемы вы можете предложить?

Пути решения тоже предлагаются в доке и, судя по тому, как часто на это место ссылается StackOverflow, 
нам даются очень жизненные напутствия, а именно:
- если проблема с сетью - надо, закономерным образом, чинить сеть.
- если проблема в слишком тяжелых запросах, то предлагается увеличить значение 
системной переменной `[net_read_timeout](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_net_read_timeout)`, 
которое по умолчанию равняется 30 секундам. Оно определяет, сколько секунд ждать, пока передаются данные, 
прежде чем прервать связь. В документации говорят для начала увеличить до 60 секунд.
- если это проблема первичного подключения, то рекомендуется проверить (и в случае необходимости увеличить) 
значение переменной 
[connect_timeout](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_connect_timeout). 
Конкретно для диагностики этого случая имеет смысл посмотреть `SHOW GLOBAL STATUS LIKE 'Aborted_connects'`.

Вообще если есть возможность не связываться с MySQL, а использовать PostgreSQL, то лучше переместиться туда.

## Задача 4


> Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
> большим объемом данных лучше, чем MySQL.
> 
> После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
> 
> `postmaster invoked oom-killer`
> 
> Как вы думаете, что происходит?

Процесс постгреса убивается omm-киллером, потому что занимает слишком много оперативной памяти, что 
угрожает работоспособности системных процессов. Иными словами, оперативной памяти не хватает.

> Как бы вы решили данную проблему?

Во-первых, есть риск, что ресурсы сервера не подходят для такой базы, и ей объективно требуется больше 
оперативной памяти. В таком случае ее лучше добавить или перенести базу на другой сервер.

Во-вторых, надо посмотреть, нет ли на сервере еще каких-нибудь жадных до памяти процессов. Если они есть, 
то желательно, опять же, как-то иначе распределить работу этих процессов и базы между серверами.

В-третьих, хорошо бы выяснить, что за запросы приходится обрабатывать СУБД - возможно, их стоит 
оптимизировать.